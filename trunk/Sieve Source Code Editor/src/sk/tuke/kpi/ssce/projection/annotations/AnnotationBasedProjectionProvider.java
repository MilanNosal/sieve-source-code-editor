package sk.tuke.kpi.ssce.projection.annotations;

import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.StringTokenizer;
import javax.swing.AbstractListModel;
import org.netbeans.api.project.Project;
import org.openide.awt.StatusDisplayer;
import org.openide.loaders.DataObject;
import org.openide.util.Exceptions;
import sk.tuke.kpi.ssce.annotations.concerns.SSCE_UI;
import sk.tuke.kpi.ssce.concerns.annotations.AnnotationBasedConcernExtractor;
import sk.tuke.kpi.ssce.concerns.interfaces.Concern;
import sk.tuke.kpi.ssce.concerns.interfaces.ConcernExtractor;
import sk.tuke.kpi.ssce.core.SSCEditorCore;
import sk.tuke.kpi.ssce.core.model.availableprojections.ProjectionsModel;
import sk.tuke.kpi.ssce.projection.provider.AbstractProjectionProvider;
import sk.tuke.kpi.ssce.sieving.annotations.AnnotationBasedSiever;

/**
 *
 * @author Milan
 */
@SSCE_UI(source = "annotations")
public class AnnotationBasedProjectionProvider extends AbstractProjectionProvider {

    private SSCEditorCore core;
    private final ConcernsListModel listModel;

    /**
     * Creates new form AnnotationBasedProjectionProvider
     */
    public AnnotationBasedProjectionProvider(Project projectContext) {
        super(projectContext);
        startProjection();
        listModel = new ConcernsListModel(core.getAvailableProjections());
        initComponents();
    }

    private void startProjection() {
        DataObject dObj = openSJDocumentForGivenProject();
        ConcernExtractor extractor = new AnnotationBasedConcernExtractor();
        AnnotationBasedSiever siever = new AnnotationBasedSiever();
        try {
            core = new SSCEditorCore(dObj, getProjectContext(), extractor, siever);
            core.getConfiguration().addCurrentProjectionChangeListener(siever);
        } catch (IOException ex) {
            Exceptions.printStackTrace(ex);
        }
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jScrollPane1 = new javax.swing.JScrollPane();
        concernsList = new javax.swing.JList();
        queryLabel = new javax.swing.JLabel();
        queryTextBox = new javax.swing.JTextField();
        sieveButton = new javax.swing.JButton();
        andCheckBox = new javax.swing.JCheckBox();

        concernsList.setModel(listModel);
        jScrollPane1.setViewportView(concernsList);

        org.openide.awt.Mnemonics.setLocalizedText(queryLabel, org.openide.util.NbBundle.getMessage(AnnotationBasedProjectionProvider.class, "AnnotationBasedProjectionProvider.queryLabel.text")); // NOI18N

        queryTextBox.setText(org.openide.util.NbBundle.getMessage(AnnotationBasedProjectionProvider.class, "AnnotationBasedProjectionProvider.queryTextBox.text")); // NOI18N

        org.openide.awt.Mnemonics.setLocalizedText(sieveButton, org.openide.util.NbBundle.getMessage(AnnotationBasedProjectionProvider.class, "AnnotationBasedProjectionProvider.sieveButton.text")); // NOI18N
        sieveButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                sieveButtonActionPerformed(evt);
            }
        });

        org.openide.awt.Mnemonics.setLocalizedText(andCheckBox, org.openide.util.NbBundle.getMessage(AnnotationBasedProjectionProvider.class, "AnnotationBasedProjectionProvider.andCheckBox.text")); // NOI18N

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 381, Short.MAX_VALUE)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(queryLabel)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(queryTextBox)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(andCheckBox)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(sieveButton)))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 244, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(queryLabel)
                    .addComponent(queryTextBox, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(sieveButton)
                    .addComponent(andCheckBox))
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );
    }// </editor-fold>//GEN-END:initComponents

    private void sieveButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_sieveButtonActionPerformed
        Set<Concern> selectedConcerns = new HashSet<Concern>();
        Map<String, Object> params = new HashMap<String, Object>();
        
        for (int i : concernsList.getSelectedIndices()) {
            selectedConcerns.add((Concern) listModel.getElementAt(i));
        }
        
        params.put("mode", andCheckBox.isSelected() ? "AND" : "OR");
        
        String paramsText = queryTextBox.getText();
        StringTokenizer tokenizer = new StringTokenizer(paramsText, ";");
        while (tokenizer.hasMoreTokens()) {
            String current = tokenizer.nextToken();
            if (current.contains("=")) {
                String key = current.substring(0, current.indexOf("=")).trim();
                String value = current.substring(current.indexOf("=") + 1).trim();
                params.put(key, value);
            }
        }
        
        core.getConfiguration().setSelectedConcerns(selectedConcerns, params);
    }//GEN-LAST:event_sieveButtonActionPerformed


    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JCheckBox andCheckBox;
    private javax.swing.JList concernsList;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JLabel queryLabel;
    private javax.swing.JTextField queryTextBox;
    private javax.swing.JButton sieveButton;
    // End of variables declaration//GEN-END:variables

    @Override
    public void dispose() {
        StatusDisplayer.getDefault().setStatusText("Attemtping to destroy the projection provider");
        core.dispose();
    }

    private class ConcernsListModel extends AbstractListModel implements ProjectionsModel.ConcernsChangeListener {

        private final ProjectionsModel model;
        // for buffering
        private final List<Concern> currentModel;

        public ConcernsListModel(ProjectionsModel model) {
            this.model = model;
            this.model.addChangeListener(this);
            currentModel = new ArrayList<Concern>(model.getAllConcerns());
        }

        @Override
        public int getSize() {
            return currentModel.size();
        }

        @Override
        public Object getElementAt(int index) {
            return currentModel.get(index);
        }

        @Override
        public void concernsChanged(ProjectionsModel.ConcernsChangedEvent event) {
            if (event.isConcernsSetChanged()) {
                int previousSize = currentModel.size();
                currentModel.clear();
                currentModel.addAll(event.getAllConcerns());
                this.fireContentsChanged(this, 0, previousSize);
            }
        }

    }
}
